from erd import *
from table import *

# This function converts an ERD object into a Database object
# The Database object should correspond to a fully correct implementation
# of the ERD, including both data structure and constraints, such that the
# CREATE TABLE statements generated by the Database object will populate an
# empty MySQL database to exactly implement the conceptual design communicated
# by the ERD.
#
# @TODO: Implement me!
def convert_to_table( erd ): # My way to solve the functions is to seperate it to different cases: number of relations
    length_of_relations=len(erd.relationships) # Find the number of relations 
    if(length_of_relations==0): # When there is no relation go to function No_relationships
        result=No_relationships(erd)

        
    if(length_of_relations==1): # When there is 1 relation go to function One_relationships
        result=One_relationships(erd)
    if(length_of_relations==2):  # When there is 2 relations go to function Two_relationships
        result=Two_relationships(erd)
    
    return result

def add_to_list(erd): # Add the entity_sets from erd.entity_sets and store them in an array so I can use it later 
    list1=[]
    counter=0
    
    for sets in erd.entity_sets:
    
        list1.append(sets)
        
    return list1
def One_relationships(erd): # When there is one relation, seperate them into different cases MANY_MANY ONE_ONE MANY_ONE OR MANY_MANY_ONE etc
    list1=[]
    counter=0
    
    list1=add_to_list(erd) # Store the entity_sets in the list 
    
    if(len(erd.entity_sets)>2): # Complex when there is more than 2 entity_sets
        if(list1[0].connections[0][1].value==1 and list1[1].connections[0][1].value ==0 and list1[2].connections[0][1].value==0): # Many_one_One case 
            if(erd.relationships[0].primary_key==[]):       # Check if relation have PK, if not then dont have to creat table for relation            
                Table_One_relationships=Many_to_One_Non_PK(erd)    # Many_to_One_Non_PK, Many one relation without PK for relation 
                
        if(list1[0].connections[0][1].value==1 and list1[1].connections[0][1].value ==1 and list1[2].connections[0][1].value==0): # Many_Many_one case 
                
                Table_One_relationships=Many_to_Many(list1,erd,2) # Go to function Many_to_Many 2 means there are two Many cases
               
    elif(list1[0].connections[0][1].value==1 and list1[1].connections[0][1].value ==1): # A normal Many_Many case 
            
        Table_One_relationships=Many_to_Many(list1,erd,0) # 0 means it is the normal case with two entity_sets
        
    elif(list1[0].connections[0][1].value==1 and list1[1].connections[0][1].value ==0):   # Mony_one case 
        if(erd.relationships[0].primary_key==[]):  # Check if relation have PK, if not then dont have to creat table for relation
            Table_One_relationships=Many_to_One_Non_PK(erd) 
            
        else:
            number=1 # It means there is PK for relation 
            Table_One_relationships=Many_to_Many(list1,erd, number) # So we have to create a table for relation I treat it as MANY_MANY case 
            
    elif(list1[0].connections[0][1].value==0 and list1[1].parents!=[]): # When there is parent 
        Table_One_relationships=One_and_parent(erd)
    
    elif(list1[0].supporting_relations!=[] or list1[1].supporting_relations!=[] ): # When it has a weak entity set 
        Table_One_relationships=weak_entity_set(erd)
                     
    return Table_One_relationships

def Two_relationships(erd): # When there is two relations same as one relationship, seperate them into different cases
    list1=[]
    counter=0
    count=0
    count2=0
    list1=add_to_list(erd)
    Table_Two_relationships=Database([])
    if(list1[0].connections[0][1].value==1 and list1[1].connections[0][1].value ==0 and list1[1].connections[1][1].value ==1): # Many_one_Many_one case 
        if(erd.relationships[0].primary_key==[] and erd.relationships[1].primary_key==[]):   # Check if relation have PK, if not then dont have to creat table for relation
            for counter in range(len(erd.entity_sets)-1): # In this we have to creat len(erd.entity_sets)-1 Many's table 
                
                Table_Two_relationships.tables.append(Many_to_one_Many(erd,counter)) # Create the Many's table
                
            Table_Two_relationships.tables.append(Many_to_One_One(erd,counter+1)) # Create the One's table
    
    
    if(all_are_Many(erd)==True): # Check if all the multiplicity in entity_sets are all equal
        Table_Two_relationships=Many_to_Many(list1,erd,3) # 3 Means there is three same multiplicity
    
    return Table_Two_relationships       

def all_are_Many(erd): # Check if all the multiplicity are equal
    count=0
    count2=0
    result=False
    for sets in erd.entity_sets:
        for connection in sets.connections:
            if (connection[1].value==1):
                count+=1
                
            count2+=1
    if(count==count2):
        result=True
    return result    

def Many_to_One_One(erd,counter): # A public function to create One's table, counter is to find which data to use in entity_sets for creating table
    name = 'T'
    attributes = set()
    primary_key = set() 
    foreign_keys = set()
    Table_No_relationships=Database([]) # Create a Database([])
    table=Table(name,attributes,primary_key,foreign_keys)
    table.name=erd.entity_sets[counter].name
    table.attributes.update(erd.entity_sets[counter].attributes)
    table.primary_key.update(erd.entity_sets[counter].primary_key)
    
    return table

def Mant_to_Many_A_PK(erd): # MANY_MANY case to create the table with only attributes and PK
    Table_No_relationships=Database([])
    counter=len(erd.entity_sets)
    for index in range(counter): # Go through every entity_sets in the ERD and create table for them
        name = 'T'
        attributes = set()
        primary_key = set() 
        foreign_keys = set()
        table=Table(name,attributes,primary_key,foreign_keys)
        table.name=erd.entity_sets[index].name
        table.attributes.update(erd.entity_sets[index].attributes)

        table.primary_key.update(erd.entity_sets[index].primary_key)
        Table_No_relationships.tables.append(table)  # Add them each time in the Database
        
    return Table_No_relationships
def Mant_to_Many_FK(erd,Table_No_relationships,number,counter,length): # Create table for the relation for MANY_MANY case, number is the case decider, 0 mean normal case, 1 means it is the case MANY_ONE with relationship contians PK, 2 means there are two or more MANY's in entity_sets. Counter means the index of start place for the entity_sets,  length means the max size. For the different cases, it needs different start place and end place, for example MANY_ONE_MANY_ONE case, we have to creat two tables with FK, the first one take the PK from first entity_sets and second entity_sets, so its FK comes from first entity_sets and second entity_sets. Then for the second take the PK from second entity_sets and third entity_sets, so its FK comes from second entity_sets and second entity_sets. So in this case the counter for table one will be 0 and length=2, for the second table counter =1 and length= 3. I hope you can understand it. Please email me if anything has bug because of misunderstanding of my Naming, my email is tangcan2014@gmail.com
                                                                          
    name = 'T'
    attributes = set()
    primary_key = set() 
    foreign_keys = set()
    
    table1=Table(name,attributes,primary_key,foreign_keys)
    table1.name=erd.relationships[counter].name # The name of the table will always be the name of Relationship
    total_range=len(erd.entity_sets)  
    counter1=counter
    counter2=counter
    counter3=counter
    while (counter<length): # Attributes will be taken from entity_sets
        table1.attributes.update(erd.entity_sets[counter].primary_key)
        counter+=1    
    
    table1.attributes.update(erd.relationships[counter1].attributes) # And its self
    if(number==1): # MANY_ONE with relationship contians PK so its PK will be Many's PK and primary_key of itself
        table1.primary_key.update(erd.entity_sets[0].primary_key)
        table1.primary_key.update(erd.relationships[0].primary_key)
    
    if(number==2): #  two or more MANY's in entity_sets, MANY_MANY_ONE case 
        while(counter3<length):
            if(length >2 and counter3<length-1):          
                table1.primary_key.update(erd.entity_sets[counter3].primary_key)   # Only need the first two entity_sets' primary_key         
            counter3+=1      
    if(number==0): # Normal case MANY_MANY
        while(counter1<length):
            if(total_range >2 and counter1<total_range-1):
                
                table1.primary_key.update(erd.entity_sets[counter1].primary_key)
            else:
                
                table1.primary_key.update(erd.entity_sets[counter1].primary_key)
            counter1+=1    
        
        table1.primary_key.update(erd.relationships[counter2].primary_key) # In case I forget to add the primary_key of itself
    
    while(counter2<length): # Create the FK
        lista=[]   # Empty the list and tuple everytimes
        listb=[]
        tuple_b=()
        tuple2=()
        tuple2=tuple(Table_No_relationships.tables[counter2].primary_key) # Transform to tuple
        lista.append(tuple2)
        lista.append(Table_No_relationships.tables[counter2].name)
        lista.append(tuple2)    # Use list to append everything we need
        tuple_b=tuple(lista)    # Transform list to tuple
        table1.foreign_keys.add(tuple_b) # Add to table 
        counter2+=1

    return table1 # Return the table with FK
def Many_to_Many(list1,erd,number):
    counter=3
    index=0
    Table_No_relationships=Mant_to_Many_A_PK(erd) # Create all the tables with only attributes and PK
    
    if(number>2): # If there are more than two entity_sets
        
        Table_No_relationships.tables.append(Mant_to_Many_FK(erd,Table_No_relationships,0,0,2)) # Start place 0, end place 2
        Table_No_relationships.tables.append(Mant_to_Many_FK(erd,Table_No_relationships,0,1,3)) # Start place 1, end place 3
    else:
        
        Table_No_relationships.tables.append(Mant_to_Many_FK(erd,Table_No_relationships,number,0,len(erd.entity_sets))) # Normal cases with only MANY_MANY
    
    return Table_No_relationships

    
def weak_entity_set(erd): # When there is a weak entity set
    Table_No_relationships=Database([])
    Table_No_relationships.tables.append(Many_to_One_One(erd,0)) # Add the table without FK
    name = 'T'
    attributes = set()
    primary_key = set()
    foreign_keys = set()
    table1=Table(name,attributes,primary_key,foreign_keys) # FK table 
    
    table1.name=erd.entity_sets[1].name  # The name will be itself 
    table1.attributes.update(erd.entity_sets[0].primary_key)  # Take weak entity set's primary_key as attributes
    table1.attributes.update(erd.entity_sets[1].attributes)
    
    table1.primary_key.update(erd.entity_sets[0].primary_key) # Take weak entity set's primary_key as primary_key
    table1.primary_key.update(erd.entity_sets[1].primary_key)
    
    total_range=len(erd.entity_sets[0].primary_key)
    for a_count in range(total_range):             # Take weak entity set's primary_key as FK
        lista=[]      
        tuple2=tuple(Table_No_relationships.tables[a_count].primary_key)
        lista.append(tuple2)
        lista.append(Table_No_relationships.tables[a_count].name)
        lista.append(tuple2)
        tuple_b=tuple(lista)
        table1.foreign_keys.add(tuple_b)
    
    Table_No_relationships.tables.append(table1) # Add to Database
    return Table_No_relationships
    
def One_and_parent(erd): # When there is a parent 
    Table_No_relationships=Database([])
    
    Table_No_relationships.tables.append(Many_to_One_One(erd,0)) # Add the table without FK
    
    name = 'T'
    attributes = set()
    primary_key = set() 
    foreign_keys = set()
    table1=Table(name,attributes,primary_key,foreign_keys) # FK table 
    table1.name=erd.entity_sets[1].name
    table1.attributes.update(erd.entity_sets[1].attributes)  # Take parent primary_key as attributes
    table1.attributes.update(erd.entity_sets[0].primary_key)
    table1.attributes.update(erd.relationships[0].attributes)
    
    table1.primary_key.update(erd.entity_sets[0].primary_key) # Take parent primary_key as primary_key
    table1.primary_key.update(erd.entity_sets[1].primary_key)
    table1.primary_key.update(erd.relationships[0].primary_key)
    total_range=len(erd.entity_sets[0].primary_key)                              
    for a_count in range(1):            # Take parent primary_key as FK
        lista=[]
        tuple2=tuple(Table_No_relationships.tables[a_count].primary_key)
        lista.append(tuple2)
        lista.append(Table_No_relationships.tables[a_count].name)
        lista.append(tuple2)
        tuple_b=tuple(lista)
        table1.foreign_keys.add(tuple_b)
    
    Table_No_relationships.tables.append(table1) # Add to Database
    
    return Table_No_relationships

def Many_to_one_Many(erd,counter): # MANY_ONE case MANY's table 
    name = 'T'
    attributes = set()
    primary_key = set()
    foreign_keys = set()
    Table_No_relationships=Database([])
    table=Table(name,attributes,primary_key,foreign_keys)
    table.name=erd.entity_sets[counter].name
    table.attributes.update(erd.entity_sets[counter].attributes) # Take One's primary_key as attributes 
    table.attributes.update(erd.entity_sets[counter+1].primary_key)
    table.attributes.update(erd.relationships[counter].attributes)
    table.primary_key.update(erd.entity_sets[counter].primary_key) # Take itself's primary_key as primary_key
    
    a_count=0
    lista=[]
        
    tuple2=tuple(erd.entity_sets[counter+1].primary_key)  # Take One's primary_key as FK
    lista.append(tuple2)
    lista.append(erd.entity_sets[counter+1].name)
    lista.append(tuple2)
    tuple_b=tuple(lista)
    table.foreign_keys.add(tuple_b) # Add to Database
    
    return table
def Many_to_One_Non_PK(erd): # MANY_ONE case that relation has PK which is MANY'S table
    name = 'T'
    attributes = set()
    primary_key = set() 
    foreign_keys = set()
    Table_No_relationships=Database([])
    table=Table(name,attributes,primary_key,foreign_keys)
    counter=1
    table.name=erd.entity_sets[0].name  # The name will be itself 
    table.attributes.update(erd.entity_sets[0].attributes) # Add attributes of itself
    total_range=len(erd.entity_sets)
    for counter in range(total_range):

        table.attributes.update(erd.entity_sets[counter].primary_key)  # Add other entity_sets' primary_key
       
    table.attributes.update(erd.relationships[0].attributes)      
    table.primary_key.update(erd.entity_sets[0].primary_key) 
    a_count=1
    while(a_count<total_range): # Find the FK for table Take MANY's primary_key as FK
        tuple2=()
        tuple_b=()
        lista=[]
        tuple2=tuple(erd.entity_sets[a_count].primary_key) 
        lista.append(tuple2)
        lista.append(erd.entity_sets[a_count].name)
        lista.append(tuple2)
        tuple_b=tuple(lista)
        table.foreign_keys.add(tuple_b)
        a_count+=1
        
    Table_No_relationships.tables.append(table)
    
    b_count=1
    while(b_count<total_range):
        Table_No_relationships.tables.append(Many_to_One_One(erd,b_count)) # Create One's table 
        b_count+=1
     
    return Table_No_relationships
    
def No_relationships(erd): # When there is no relationship, then it is simply store the data into the place they should be, since there is no relationship, it will only have one entity_sets 
    name = 'T'
    attributes = set()
    primary_key = set()
    foreign_keys = set()
    tables=[Table(name,attributes,primary_key,foreign_keys)]
    
    Table_No_relationships=Database(tables)
    
    Table_No_relationships.tables[0].name=erd.entity_sets[0].name
    Table_No_relationships.tables[0].attributes.update(erd.entity_sets[0].attributes)
    Table_No_relationships.tables[0].primary_key.update(erd.entity_sets[0].primary_key)

    return Table_No_relationships